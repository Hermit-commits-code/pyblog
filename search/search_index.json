{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the Python Blog","text":"<p>This is my technical journal where I share insights on Python development and forensic tools.</p>"},{"location":"#featured-project","title":"Featured Project","text":"<p>Check out the Origin-Miner Case Study.</p>"},{"location":"404/","title":"404 - Page Not Found","text":"<p>It looks like you've wandered into an uninitialized branch!</p> <p>The page you are looking for might have been moved, deleted, or perhaps it hasn't been written yet.</p> <p>Return to Home Screen{ .md-button .md-button--primary }</p>"},{"location":"about/","title":"About Me","text":"<p>Hi, I'm Joe. I build Python tools that focus on digital forensics and automation.</p>"},{"location":"about/#my-journey","title":"My Journey","text":"<p>This blog started as a way to document the development of Origin-Miner, a tool I built to solve the \"LLM Signature\" problem in modern software development. I believe that as AI becomes more prevalent, understanding the human element in code becomes even more critical.</p>"},{"location":"about/#what-im-working-on","title":"What I'm Working On","text":"<ul> <li>Origin-Miner: Continuing to refine the forensic scoring logic.</li> <li>This Blog: Sharing the \"under the hood\" details of my Python projects.</li> <li>Automation: Exploring ways to make the dev-to-deploy pipeline as invisible as possible.</li> </ul> <p>Find me on GitHub</p>"},{"location":"posts/hello-world/","title":"Hello World","text":"<p>Published: February 12, 2026</p> <p>This is my first post on my new automated Python blog!</p>"},{"location":"posts/log-sieve-p1/","title":"Project: Log-Sieve (Part 1) - Detecting Impossible Travel","text":"<p>What is \"Impossible Travel\"? It's the digital equivalent of seeing someone walk through a front door in New York and out a back door in London five seconds later.</p>","tags":["Python","Cybersecurity","Threat-Hunting"]},{"location":"posts/log-sieve-p1/#the-security-gap","title":"The Security Gap","text":"<p>Standard authentication logs tell you who logged in, but they don't tell you if it's physically possible for that person to be there.</p>","tags":["Python","Cybersecurity","Threat-Hunting"]},{"location":"posts/log-sieve-p1/#the-logic","title":"The Logic","text":"<p>The Log-Sieve is a Python-based forensic tool I\u2019m building to:</p> <ol> <li>Parse system logs for successful logins.</li> <li>Geocode the IP addresses to find Latitude/Longitude.</li> <li>Compare the time-delta between consecutive logins.</li> <li>Calculate if the speed required to travel between those two points exceeds the speed of a commercial jet.</li> </ol> <p>If the speed is 5,000 mph, we don't just have a login; we have a compromised credential.</p>","tags":["Python","Cybersecurity","Threat-Hunting"]},{"location":"posts/log-sieve-p2/","title":"Project: Log-Sieve (Part 2) - From Raw Text to Coordinates","text":"<p>The first challenge of building a security detective is teaching it to \"read.\" System logs are messy, but they follow a strict structure that we can exploit.</p>","tags":["Python","Regex","Geolocation"]},{"location":"posts/log-sieve-p2/#step-1-regex-extraction","title":"Step 1: Regex Extraction","text":"<p>I used a Regular Expression to slice through the standard Linux <code>auth.log</code> format. By targeting the \"Accepted password\" string, I was able to pull the three critical pieces of evidence:</p> <ol> <li>The Timestamp: When the event happened.</li> <li>The User: Whose account was accessed.</li> <li>The IP Address: The digital origin of the login.</li> </ol>","tags":["Python","Regex","Geolocation"]},{"location":"posts/log-sieve-p2/#step-2-adding-a-sense-of-place","title":"Step 2: Adding a \"Sense of Place\"","text":"<p>An IP address is just a number. To turn it into a location, I integrated the <code>ip-api.com</code> service via the Python <code>requests</code> library.</p> <p>Now, instead of just seeing <code>1.1.1.1</code>, the script reports Hong Kong. This enrichment is the foundation for our \"Impossible Travel\" detection logic.</p>","tags":["Python","Regex","Geolocation"]},{"location":"posts/log-sieve-p2/#whats-next","title":"What's Next?","text":"<p>Now that we have the coordinates (Latitude and Longitude), we need to calculate the physical distance between consecutive logins. If the distance is 10,000 miles and the time difference is only 10 minutes, we've found our smoking gun.</p>","tags":["Python","Regex","Geolocation"]},{"location":"posts/log-sieve-p3/","title":"Project: Log-Sieve (Part 3) - The Impossible Verdict","text":"<p>In the final phase of this project, I integrated the Haversine Formula to bridge the gap between simple data extraction and actionable security intelligence.</p>","tags":["Python","Mathematics","Cybersecurity"]},{"location":"posts/log-sieve-p3/#the-math-of-a-sphere","title":"The Math of a Sphere","text":"<p>Standard flat geometry doesn't work for global tracking. By implementing the Haversine formula, the script calculates the \"Great Circle\" distance between two sets of coordinates.</p>","tags":["Python","Mathematics","Cybersecurity"]},{"location":"posts/log-sieve-p3/#live-test-results","title":"Live Test Results","text":"<p>Analyzing my mock authentication logs produced a staggering result:</p> <ul> <li>Login 1: Pensacola, FL</li> <li>Login 2: Hong Kong (10 minutes later)</li> <li>Calculated Distance: 13,711.42 km</li> </ul>","tags":["Python","Mathematics","Cybersecurity"]},{"location":"posts/log-sieve-p3/#conclusion-security-through-geometry","title":"Conclusion: Security Through Geometry","text":"<p>By tracking the <code>last_location</code> state and comparing it to current hits, the Log-Sieve mathematically proves when an account has been compromised. Even if a hacker has your password, they cannot break the laws of physics.</p>","tags":["Python","Mathematics","Cybersecurity"]},{"location":"posts/metadata-stripper-p1/","title":"Project: Exif-Eraser (Part 1) - The Hidden Payload","text":"<p>When you upload a photo to this blog, you aren't just uploading pixels. You're uploading a digital fingerprint.</p>","tags":["Python","Forensics","Privacy"]},{"location":"posts/metadata-stripper-p1/#the-forensic-problem","title":"The Forensic Problem","text":"<p>Every JPEG contains a header called EXIF (Exchangeable Image File Format). In a typical photo, this header reveals:</p> <ul> <li>GPS Coordinates: Where the photo was taken (latitude/longitude).</li> <li>Device Identity: Your camera model and serial number.</li> <li>Software: The exact version of the editor you used.</li> </ul>","tags":["Python","Forensics","Privacy"]},{"location":"posts/metadata-stripper-p1/#the-goal","title":"The Goal","text":"<p>Build a Python tool that recursively \"nukes\" this metadata block while keeping the image quality at 100%.</p>","tags":["Python","Forensics","Privacy"]},{"location":"posts/metadata-stripper-p1/#the-dry-run-philosophy","title":"The \"Dry Run\" Philosophy","text":"<p>A professional forensic tool shouldn't be a \"black box.\" My first step was implementing a Dry Run mode. This allows me to audit my <code>docs/assets</code> folder to see exactly what hidden data is lurking in my project before I commit to a sweep.</p> <p>Next Up: In Part 2, I'll deep-dive into the <code>Pillow</code> logic and how I solved the <code>ImagingCore</code> type-hinting issues.</p>","tags":["Python","Forensics","Privacy"]},{"location":"posts/metadata-stripper-p2/","title":"Project: Exif-Eraser (Part 2) - Fighting the Linter","text":"<p>Building a tool isn't just about the logic; it's about making the code maintainable and \"clean\" for modern IDEs.</p>","tags":["Python","Refactoring","TypeHinting"]},{"location":"posts/metadata-stripper-p2/#the-type-hinting-trap","title":"The Type-Hinting Trap","text":"<p>While building the core stripping logic, I ran into a persistent error from Pylance:</p> <p><code>Argument of type \"ImagingCore\" cannot be assigned to parameter \"iterable\"</code></p> <p>This happened because I was trying to manually iterate over pixels using <code>list(img.getdata())</code>. While this works in older Python scripts, modern linters struggle with Pillow's internal C-optimized objects.</p>","tags":["Python","Refactoring","TypeHinting"]},{"location":"posts/metadata-stripper-p2/#the-solution-imgcopy","title":"The Solution: img.copy()","text":"<p>Instead of rebuilding the image pixel-by-pixel, I refactored the code to use Pillow's native <code>copy()</code> method.</p> <p>Old Code (Buggy):</p> <pre><code>data = list(img.getdata())\nclean_img = Image.new(img.mode, img.size)\nclean_img.putdata(data)\n</code></pre>","tags":["Python","Refactoring","TypeHinting"]},{"location":"posts/metadata-stripper-p2/#what-i-added-the-fix","title":"What I added (The Fix)","text":"<pre><code>with Image.open(file_path) as img:\n    clean_img = img.copy() # Keeps pixels, drops the pointer to metadata\n    clean_img.save(clean_path, exif=bytes()) # Nukes the EXIF block\n</code></pre> <p>This approach is faster, uses less memory, and\u2014most importantly\u2014satisfied the linter.</p>","tags":["Python","Refactoring","TypeHinting"]},{"location":"posts/metadata-stripper-p3/","title":"Project: Exif-Eraser (Part 3) - The Full Implementation","text":"<p>In this final installment, we move from a single-file script to a recursive CLI tool capable of auditing and cleaning entire project directories.</p>","tags":["Python","Automation","Security"]},{"location":"posts/metadata-stripper-p3/#recursive-directory-walking","title":"Recursive Directory Walking","text":"<p>Using Python's <code>os.walk</code>, we can traverse deep into folder structures to find assets. A critical part of this logic was ensuring we didn't get caught in an infinite loop or accidentally re-process files we've already cleaned.</p>","tags":["Python","Automation","Security"]},{"location":"posts/metadata-stripper-p3/#the-implementation-logic","title":"The Implementation Logic","text":"<p>We used a naming convention filter <code>_clean</code> to identify files that have already been sanitized.</p> <pre><code># snippet of our recursive filter\nif file.lower().endswith(valid_exts) and \"_clean\" not in file:\n    full_path = os.path.join(root, file)\n    strip_image_metadata(full_path, dry_run=dry_run)\n</code></pre>","tags":["Python","Automation","Security"]},{"location":"posts/metadata-stripper-p3/#the-safety-protocol-dry-run","title":"The Safety Protocol: Dry Run","text":"<p>As discussed in Part 1, forensic tools must be non-destructive by default. My implementation defaults to dry_run=True, which simply logs the files to the terminal without touching the disk.</p> <p>This allowed me to audit my ./docs/assets folder and discover exactly which screenshots were leaking system data before performing a bulk sanitize. Conclusion</p> <p>The Exif-Eraser is now a permanent part of my deployment pipeline. Every image uploaded to this blog now passes through this filter, ensuring that my privacy\u2014and my GPS coordinates\u2014remain private.</p>","tags":["Python","Automation","Security"]},{"location":"posts/origin-miner-case-study/","title":"Forensic Git Auditing: Introducing Origin-Miner v1.0.1","text":"<p>Published: February 12, 2026</p> <p>How can you tell the difference between a human writing code and an AI pasting it? That was the question that led me to build Origin-Miner.</p>","tags":["Python","Git","Forensics"]},{"location":"posts/origin-miner-case-study/#the-problem-the-llm-signature","title":"The Problem: The \"LLM Signature\"","text":"<p>Traditional Git statistics focus on lines of code (LOC). However, in the age of AI, volume is cheap. What matters now is velocity and intent.</p>","tags":["Python","Git","Forensics"]},{"location":"posts/origin-miner-case-study/#the-forensic-logic","title":"The Forensic Logic","text":"<p>Our engine uses a multi-factor scoring system to determine if a commit is \"suspicious.\" One of the core metrics is Lines Per Minute (LPM).</p> \\[\\text{LPM} = \\frac{\\Delta \\text{Lines}}{\\Delta \\text{Time (Minutes)}}\\] <p>If a developer \"writes\" 500 lines of complex logic in 2 minutes, the LPM spikes, and the suspicion gate (currently calibrated at 75%) triggers a flag.</p>","tags":["Python","Git","Forensics"]},{"location":"posts/origin-miner-case-study/#key-features","title":"Key Features","text":"<ul> <li>SQLite Caching: High-performance auditing that doesn't re-scan the same history twice.</li> <li>Rich CLI: Beautiful terminal output for quick team audits.</li> <li>Forensic Normalization: Our logic accounts for \"bursty\" coding patterns to avoid false positives on boilerplate.</li> </ul>","tags":["Python","Git","Forensics"]},{"location":"posts/origin-miner-case-study/#installation","title":"Installation","text":"<p>You can install the tool directly from PyPI:</p> <p>```bash uv tool install origin-miner miner --path .</p>","tags":["Python","Git","Forensics"]},{"location":"projects/origin-miner/","title":"Origin-Miner","text":"<p>I recently finished building a Git forensic tool. You can find it on PyPI!</p>"}]}